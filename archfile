сразу уточню, я все делаю из-под рута. это может быть триста раз неправильно, и на живом
сервере так лучше не делать, будет куча проблем с правами и вероятными залетами, типа запустил/покалечил
не то что надо и тд.
итак, как вообще работает вся эта хуйня. предполагается, что понятия "манифест" "модуль" и "класс" уже
знакомы.
основной манифест, по которому работает puppet, это

/etc/puppet/manifests/site.pp

в нем можно прописать в общем-то все что угодно, но самое главное для меня на данный момент,
это то, что там прописывается адресат.

    node default { }

    это "все наличные ноды". то есть, если указать что-то типа
    node default {
    include fuck
    }
	то класс fuck будет применен ко всем нодам, подключенным к серверу.
	предпочитаемые адресаты прописываются отдельно. например, у меня есть нода с именем сертификата ubuntu
	чтобы отправить таску именно на эту ноду, надо указать
    node 'ubuntu' {
    include fuck
    }
	и удалить include fuck из списка задач в default, выглядеть это будет так
    node default { }
    node 'ubuntu' {
    include fuck
    }

	и тогда инструкция на выполнение класса fuck отправится только на эту ноду

далее, при создании своего модуля, можно пойти двумя путями.

первый, это создать модуль вручную.
	для этого понадобится выяснить, где именно сервер по умолчанию хранит модули. это можно посмотреть в конфиге,
	а можно и через консоль, так быстрее

    puppet config print modulepath

	в моем случае вывод следующий

    /usr/share/puppet/modules

	вообще, он может вести и в /etc/puppet/modules
	или в ад. вариантов много.

	когда мы выяснили, где пупет будет искать модули, то по указанному адресу создаем папку для собственно модуля
	и папку, критически необходимую для его функционала
	я назову модуль testmodule

    mkdir -p /usr/share/puppet/modules/testmodule/manifests

	как результат, есть минимально необходимая архитектура модуля - папка с его названием и папка для манифестов.
	в папке для манифестов создаем критически необходимый файл

    touch /usr/share/puppet/modules/testmodule/manifests/init.pp

	файл init.pp это фактически сердце модуля, основная инструкция, по которой он будет работать. В этом файле
	содержатся правила взаимодействия всех элементов модуля. на данный момент, в порядке минимального эксперимента, 
	я обойдусь без разветвления. итак, файл init.pp создан.Надо задать ему содержимое. В моем случае это будет класс, подразумевающий
	выполнение команды wall

    class testmodule {
    exec { 'wall':
    command => '/usr/bin/wall THIS IS A TEST MODULE'
    }
    }
	критически важно, чтобы заданный в данном случае класс назывался по имени модуля, в противном случае, и клиент и сервер будут материться на "модуль/класс не найден".
	также, имя исполняемой команды может быть произвольным, но нигде не должно повторяться.
	То есть, если есть exec { 'wall' }, то другого такого экзека в активных модулях быть не должно. ругается на невозможность
	переназначить.

	то есть, фактически, инклюд класса подхватывает его либо в основном документе, site.pp , либо в модулях.

второй способ, это генерация модуля инструментами самого папета. модуль будет создан в папке пребывания пользователя на момент команды.

    puppet module generate me-autotest --skip-interview
  
        данная команда генерирует модуль по всем правилам. название модуля me-autotest
        me- потому что команда требует указать имя автора, или хз, но приставка обязательна, иначе будет ругаться.
        --skip-interview для того, чтобы избежать утомительного заполнения данных, которые потребует паппет при генерации
        модуля.
        модуль будет сгенерирован по всем правилам, со всеми нужными и просто полезными подпапками и файлами.

    puppet module uninstall me-autotest 

	эта команда удалит созданный таким способом модуль.

